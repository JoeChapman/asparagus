{"name":"Asparagus","tagline":"Template compile tool for Node and JavaScript","body":"Compile all or some of your templates, even those in parallel sub-folders, to a location that may or may not yet exist.\r\n\r\n[![Build Status](https://travis-ci.org/JoeChapman/asparagus.svg?branch=master)](https://travis-ci.org/JoeChapman/asparagus)\r\n[![NPM version](https://badge.fury.io/js/asparagus.svg)](http://badge.fury.io/js/asparagus)\r\n\r\n### Install globally to use the binary commmands\r\n\r\n```\r\n$ npm install asparagus -g\r\n```\r\n\r\nadds a binary to the path so you can run *asparagus* from the command line\r\n\r\n#### Command line\r\n\r\n```\r\n$ asparagus /path/to/source/folder namespace=mytemplates format=camelcase\r\n```\r\n\r\n#### JavaScript\r\n```\r\nvar asparagus = require('aspargus');\r\n\r\n// A source parameter is required as the first argument to asparagus\r\n\r\nasparagus(__dirname + '/views', {\r\n    dest: __dirname + '/public/templates',\r\n    format: 'camelcase',\r\n    namespace: 'partials',\r\n    basedir: __dirname + '/views/dev',\r\n    exclusive: 'includes'\r\n});\r\n```\r\n\r\n**Plays nice with Gulp too** simply wrap the above in a gulp task, I.e.,\r\n\r\n```\r\nvar gulp = require('gulp'),\r\n    asparagus = require('asparagus');\r\n\r\ngulp.task('asparagus', function () {\r\n    asparagus(__dirname + '/views', {\r\n        dest: __dirname + '/public/templates',\r\n        format: 'camelcase',\r\n        namespace: 'partials',\r\n        basedir: __dirname + '/views/dev',\r\n        exclusive: 'includes'\r\n});\r\n```\r\n\r\n#### Browser\r\nTemplates are added to the namespace by the function name corresponding to their filename.\r\nIf you are using [Jade](http://jade-lang.com/), you'll need to include [Jade Runtime](https://raw.githubusercontent.com/visionmedia/jade/master/runtime.js) in the browser.\r\n```\r\nwindow.partials = {\r\n    functionName: function () { ..... }\r\n};\r\n```\r\n\r\n\r\n### Options\r\n```\r\n[dest] {String}\r\n    - The final intended destination of the compiled templates(s), defaults to the value of the source parameter.\r\n\r\n[format] {String}\r\n    - The format of each compiled template function name in the namespace, defaults to 'underscore' delimited function names.\r\n\r\n[namespace] {String}\r\n    - The namespace object on the `window` object that will store references to the compiled template functions, defaults to 'templates'.\r\n\r\n[basedir] {String}\r\n    - allows for absolute include paths, defaults to the value of the source parameter.\r\n\r\n[exclusive] {String}\r\n    - When set to an existing directory name in the source path, compiles files only from and to that directory name within source and dest paths.\r\n\r\n```\r\n\r\n\r\n### Explained\r\n\r\nThe following example will compile all and only, the files in the folder named 'includes' within the path; `__dirname + 'views/source'`.\r\n\r\nThe compiled functions will be assigned to a hash called 'partials' and attached to the `window` object.\r\n\r\nEach compiled template function within `window.partials` will be identifiable by an id created from its original filename and formatted as per the format option, which in this case is 'camelcase'\r\n\r\n*So this*;\r\n```\r\nviews/\r\n    dev/\r\n        includes/\r\n            my-tmpl.jade\r\n    en/\r\n        includes/\r\n            my-tmpl.jade\r\n```\r\n\r\n*Outputs*;\r\n```\r\npublic/\r\n    templates/\r\n        dev/\r\n            includes/\r\n                my-tmpl.js\r\n        en/\r\n            includes/\r\n                my-tmpl.js\r\n```\r\n\r\n*And when one is loaded*\r\n```\r\n<script src='templates/en/includes/my-tmpl.js'></script>\r\n```\r\n\r\n*Gives you*\r\n```\r\nwindow.partials = {\r\n    myTmpl: function () { ..... }\r\n};\r\n```\r\nAny absolute include statements within any of the original templates will be appended to the basedir option, __dirname + '/views/dev'.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}